"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSuggestionsForInsideAttributes = exports.getTypesFromCurrentBlock = exports.getSuggestionForSupportedFields = exports.getValuesInsideBrackets = exports.suggestEqualSymbol = exports.getSuggestionForBlockTypes = exports.getSuggestionForFirstInsideBlock = exports.getSuggestionsForTypes = exports.getAllRelationNames = exports.getSuggestionForFieldAttribute = exports.getSuggestionForNativeTypes = exports.positionIsAfterFieldAndType = exports.getSymbolBeforePosition = exports.isInsideQuotationMark = exports.isInsideAttribute = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const completionUtil_1 = require("./completionUtil");
const klona_1 = require("klona");
const renameUtil_1 = require("../rename/renameUtil");
const previewFeatures_1 = __importDefault(require("../prisma-fmt/previewFeatures"));
const nativeTypes_1 = __importDefault(require("../prisma-fmt/nativeTypes"));
const util_1 = require("../util");
function toCompletionItems(allowedTypes, kind) {
    return allowedTypes.map((label) => ({ label, kind }));
}
/***
 * @param symbols expects e.g. '()', '[]' or '""'
 */
function isInsideAttribute(currentLineUntrimmed, position, symbols) {
    let numberOfOpenBrackets = 0;
    let numberOfClosedBrackets = 0;
    for (let i = 0; i < position.character; i++) {
        if (currentLineUntrimmed[i] === symbols[0]) {
            numberOfOpenBrackets++;
        }
        else if (currentLineUntrimmed[i] === symbols[1]) {
            numberOfClosedBrackets++;
        }
    }
    return numberOfOpenBrackets > numberOfClosedBrackets;
}
exports.isInsideAttribute = isInsideAttribute;
/***
 * Checks if inside e.g. "here"
 * Does not check for escaped quotation marks.
 */
function isInsideQuotationMark(currentLineUntrimmed, position) {
    let insideQuotation = false;
    for (let i = 0; i < position.character; i++) {
        if (currentLineUntrimmed[i] === '"') {
            insideQuotation = !insideQuotation;
        }
    }
    return insideQuotation;
}
exports.isInsideQuotationMark = isInsideQuotationMark;
function getSymbolBeforePosition(document, position) {
    return document.getText({
        start: {
            line: position.line,
            character: position.character - 1,
        },
        end: { line: position.line, character: position.character },
    });
}
exports.getSymbolBeforePosition = getSymbolBeforePosition;
function positionIsAfterFieldAndType(position, document, wordsBeforePosition) {
    const symbolBeforePosition = getSymbolBeforePosition(document, position);
    const symbolBeforeIsWhiteSpace = symbolBeforePosition.search(/\s/);
    const hasAtRelation = wordsBeforePosition.length === 2 && symbolBeforePosition === '@';
    const hasWhiteSpaceBeforePosition = wordsBeforePosition.length === 2 && symbolBeforeIsWhiteSpace !== -1;
    return (wordsBeforePosition.length > 2 ||
        hasAtRelation ||
        hasWhiteSpaceBeforePosition);
}
exports.positionIsAfterFieldAndType = positionIsAfterFieldAndType;
/**
 * Removes all block attribute suggestions that are invalid in this context. E.g. `@@id()` when already used should not be in the suggestions.
 */
function removeInvalidAttributeSuggestions(supportedAttributes, block, lines) {
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (key === block.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (key === block.end.line) {
            break;
        }
        if (item.includes('@id')) {
            supportedAttributes = supportedAttributes.filter((attribute) => !attribute.label.includes('id'));
        }
    }
    return supportedAttributes;
}
function getSuggestionForBlockAttribute(block, lines) {
    if (block.type !== 'model') {
        return [];
    }
    // create deep copy
    let suggestions = klona_1.klona(completionUtil_1.blockAttributes);
    suggestions = removeInvalidAttributeSuggestions(suggestions, block, lines);
    return suggestions;
}
function getSuggestionForNativeTypes(foundBlock, wordsBeforePosition, document, binPath, lines) {
    const activeFeatureFlag = declaredNativeTypes(document, binPath);
    if (foundBlock.type !== 'model' ||
        !activeFeatureFlag ||
        wordsBeforePosition.length < 2) {
        return undefined;
    }
    const datasourceName = getFirstDatasourceName(lines);
    if (!datasourceName ||
        wordsBeforePosition[wordsBeforePosition.length - 1] !== `@${datasourceName}`) {
        return undefined;
    }
    const prismaType = wordsBeforePosition[1].replace('?', '').replace('[]', '');
    const suggestions = getNativeTypes(document, prismaType, binPath);
    return {
        items: suggestions,
        isIncomplete: true,
    };
}
exports.getSuggestionForNativeTypes = getSuggestionForNativeTypes;
function getSuggestionForFieldAttribute(block, currentLine, lines, wordsBeforePosition, document, binPath) {
    if (block.type !== 'model') {
        return;
    }
    // create deep copy
    let suggestions = klona_1.klona(completionUtil_1.fieldAttributes);
    const enabledNativeTypes = declaredNativeTypes(document, binPath);
    if (!(currentLine.includes('Int') || currentLine.includes('String'))) {
        // id not allowed
        suggestions = suggestions.filter((sugg) => sugg.label !== '@id');
    }
    if (!currentLine.includes('DateTime')) {
        // updatedAt not allowed
        suggestions = suggestions.filter((sugg) => sugg.label !== '@updatedAt');
    }
    suggestions = removeInvalidAttributeSuggestions(suggestions, block, lines);
    if (enabledNativeTypes && wordsBeforePosition.length >= 2) {
        const datasourceName = getFirstDatasourceName(lines);
        const prismaType = wordsBeforePosition[1];
        const nativeTypeSuggestions = getNativeTypes(document, prismaType, binPath);
        if (datasourceName && nativeTypeSuggestions.length !== 0) {
            if (!currentLine.includes('@' + datasourceName)) {
                suggestions.push({
                    kind: vscode_languageserver_1.CompletionItemKind.Property,
                    label: '@' + datasourceName,
                    documentation: 'Defines a custom type that should be used for this field.',
                });
            }
            else {
                suggestions.push(...nativeTypeSuggestions);
            }
        }
        else {
            console.log('Did not receive any native type suggestions from prisma-fmt call.');
        }
    }
    return {
        items: suggestions,
        isIncomplete: false,
    };
}
exports.getSuggestionForFieldAttribute = getSuggestionForFieldAttribute;
function getFirstDatasourceName(lines) {
    const datasourceBlockFirstLine = lines.find((l) => l.startsWith('datasource') && l.includes('{'));
    if (!datasourceBlockFirstLine) {
        return undefined;
    }
    const indexOfBracket = datasourceBlockFirstLine.indexOf('{');
    return datasourceBlockFirstLine
        .slice('datasource'.length, indexOfBracket)
        .trim();
}
function getAllRelationNames(lines) {
    const modelNames = [];
    for (const item of lines) {
        if ((item.includes('model') || item.includes('enum')) &&
            item.includes('{')) {
            // found a block
            const blockName = renameUtil_1.extractModelName(item);
            modelNames.push(blockName);
            // block is at least 2 lines long
        }
    }
    return modelNames;
}
exports.getAllRelationNames = getAllRelationNames;
function getSuggestionsForTypes(foundBlock, lines, position, currentLineUntrimmed) {
    // create deep copy
    const suggestions = klona_1.klona(completionUtil_1.corePrimitiveTypes);
    if (foundBlock instanceof util_1.Block) {
        // get all model names
        const modelNames = getAllRelationNames(lines);
        suggestions.push(...toCompletionItems(modelNames, vscode_languageserver_1.CompletionItemKind.Reference));
    }
    const wordsBeforePosition = currentLineUntrimmed
        .slice(0, position.character)
        .split(' ');
    const wordBeforePosition = wordsBeforePosition[wordsBeforePosition.length - 1];
    const completeSuggestions = suggestions.filter((s) => s.label.length === wordBeforePosition.length);
    if (completeSuggestions.length !== 0) {
        for (const sugg of completeSuggestions) {
            suggestions.push({
                label: `${sugg.label}?`,
                kind: sugg.kind,
                documentation: sugg.documentation,
            }, {
                label: `${sugg.label}[]`,
                kind: sugg.kind,
                documentation: sugg.documentation,
            });
        }
    }
    return {
        items: suggestions,
        isIncomplete: true,
    };
}
exports.getSuggestionsForTypes = getSuggestionsForTypes;
/**
 * Removes all field suggestion that are invalid in this context. E.g. fields that are used already in a block will not be suggested again.
 * This function removes all field suggestion that are invalid in a certain context. E.g. in a generator block `provider, output, platforms, pinnedPlatForm`
 * are possible fields. But those fields are only valid suggestions if they haven't been used in this block yet. So in case `provider` has already been used, only
 * `output, platforms, pinnedPlatform` will be suggested.
 */
function removeInvalidFieldSuggestions(supportedFields, block, lines, position) {
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (key === block.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine || key === position.line) {
            continue;
        }
        if (key === block.end.line) {
            break;
        }
        const fieldName = item.replace(/ .*/, '');
        if (supportedFields.includes(fieldName)) {
            supportedFields = supportedFields.filter((field) => field !== fieldName);
        }
    }
    return supportedFields;
}
function getSuggestionForDataSourceField(block, lines, position) {
    // create deep copy
    const suggestions = klona_1.klona(completionUtil_1.supportedDataSourceFields);
    const labels = removeInvalidFieldSuggestions(suggestions.map((item) => item.label), block, lines, position);
    return suggestions.filter((item) => labels.includes(item.label));
}
function getSuggestionForGeneratorField(block, lines, position) {
    // create deep copy
    const suggestions = klona_1.klona(completionUtil_1.supportedGeneratorFields);
    const labels = removeInvalidFieldSuggestions(suggestions.map((item) => item.label), block, lines, position);
    return suggestions.filter((item) => labels.includes(item.label));
}
/**
 * gets suggestions for block typ
 */
function getSuggestionForFirstInsideBlock(blockType, lines, position, block) {
    let suggestions = [];
    switch (blockType) {
        case 'datasource':
            suggestions = getSuggestionForDataSourceField(block, lines, position);
            break;
        case 'generator':
            suggestions = getSuggestionForGeneratorField(block, lines, position);
            break;
        case 'model':
            suggestions = getSuggestionForBlockAttribute(block, lines);
            break;
    }
    return {
        items: suggestions,
        isIncomplete: false,
    };
}
exports.getSuggestionForFirstInsideBlock = getSuggestionForFirstInsideBlock;
function getSuggestionForBlockTypes(lines) {
    // create deep copy
    const suggestions = klona_1.klona(completionUtil_1.allowedBlockTypes);
    // enum is not supported in sqlite
    let foundDataSourceBlock = false;
    for (const item of lines) {
        if (item.includes('datasource')) {
            foundDataSourceBlock = true;
            continue;
        }
        if (foundDataSourceBlock) {
            if (item.includes('}')) {
                break;
            }
            if (item.startsWith('provider') && item.includes('sqlite')) {
                suggestions.pop();
            }
        }
        if (!suggestions.map((sugg) => sugg.label).includes('enum')) {
            break;
        }
    }
    return {
        items: suggestions,
        isIncomplete: false,
    };
}
exports.getSuggestionForBlockTypes = getSuggestionForBlockTypes;
function suggestEqualSymbol(blockType) {
    if (!(blockType == 'datasource' || blockType == 'generator')) {
        return;
    }
    const equalSymbol = { label: '=' };
    return {
        items: [equalSymbol],
        isIncomplete: false,
    };
}
exports.suggestEqualSymbol = suggestEqualSymbol;
function getValuesInsideBrackets(line) {
    const regexp = /\[([^\]]+)\]/;
    const matches = regexp.exec(line);
    if (!matches || !matches[1]) {
        return [];
    }
    const result = matches[1].split(',');
    return result.map((v) => v.trim().replace('"', '').replace('"', ''));
}
exports.getValuesInsideBrackets = getValuesInsideBrackets;
function declaredNativeTypes(document, binPath) {
    const nativeTypes = nativeTypes_1.default(binPath, document.getText());
    if (nativeTypes.length === 0) {
        return false;
    }
    return true;
}
function handlePreviewFeatures(previewFeaturesArray, position, currentLineUntrimmed, isInsideQuotation) {
    let previewFeatures = previewFeaturesArray.map((pf) => vscode_languageserver_1.CompletionItem.create(pf));
    if (isInsideAttribute(currentLineUntrimmed, position, '[]')) {
        if (isInsideQuotation) {
            const usedValues = getValuesInsideBrackets(currentLineUntrimmed);
            previewFeatures = previewFeatures.filter((t) => !usedValues.includes(t.label));
            return {
                items: previewFeatures,
                isIncomplete: true,
            };
        }
        else {
            return {
                items: completionUtil_1.previewFeaturesArguments.filter((arg) => !arg.label.includes('[')),
                isIncomplete: true,
            };
        }
    }
    else {
        return {
            items: completionUtil_1.previewFeaturesArguments.filter((arg) => !arg.label.includes('"')),
            isIncomplete: true,
        };
    }
}
function getNativeTypes(document, prismaType, binPath) {
    let nativeTypes = nativeTypes_1.default(binPath, document.getText());
    if (nativeTypes.length === 0) {
        return [];
    }
    const suggestions = [];
    nativeTypes = nativeTypes.filter((n) => n.prisma_types.includes(prismaType));
    nativeTypes.forEach((element) => {
        if (element._number_of_args + element._number_of_optional_args !== 0) {
            let documentation = '';
            if (element._number_of_optional_args !== 0) {
                documentation = `${documentation}Number of optional arguments: ${element._number_of_optional_args}.\n'`;
            }
            if (element._number_of_args !== 0) {
                documentation = `${documentation}Number of required arguments: ${element._number_of_args}.\n`;
            }
            suggestions.push({
                label: `${element.name}()`,
                kind: vscode_languageserver_1.CompletionItemKind.TypeParameter,
                insertText: `${element.name}($0)`,
                documentation: { kind: vscode_languageserver_1.MarkupKind.Markdown, value: documentation },
                insertTextFormat: 2,
            });
        }
        else {
            suggestions.push({
                label: element.name,
                kind: vscode_languageserver_1.CompletionItemKind.TypeParameter,
            });
        }
    });
    return suggestions;
}
function getSuggestionForSupportedFields(blockType, currentLine, currentLineUntrimmed, position, binPath) {
    let suggestions = [];
    const isInsideQuotation = isInsideQuotationMark(currentLineUntrimmed, position);
    switch (blockType) {
        case 'generator':
            if (currentLine.startsWith('provider')) {
                const providers = completionUtil_1.generatorProviders;
                if (isInsideQuotation) {
                    return {
                        items: providers,
                        isIncomplete: true,
                    };
                }
                else {
                    return {
                        items: completionUtil_1.generatorProviderArguments,
                        isIncomplete: true,
                    };
                }
            }
            if (currentLine.startsWith('previewFeatures')) {
                const generatorPreviewFeatures = previewFeatures_1.default(binPath, false);
                if (generatorPreviewFeatures.length > 0) {
                    return handlePreviewFeatures(generatorPreviewFeatures, position, currentLineUntrimmed, isInsideQuotation);
                }
            }
            break;
        case 'datasource':
            if (currentLine.startsWith('provider')) {
                let providers = klona_1.klona(completionUtil_1.dataSourceProviders);
                if (isInsideAttribute(currentLineUntrimmed, position, '[]')) {
                    // return providers that haven't been used yet
                    if (isInsideQuotation) {
                        const usedValues = getValuesInsideBrackets(currentLineUntrimmed);
                        providers = providers.filter((t) => !usedValues.includes(t.label));
                        return {
                            items: providers,
                            isIncomplete: true,
                        };
                    }
                    else {
                        return {
                            items: completionUtil_1.dataSourceProviderArguments.filter((arg) => !arg.label.includes('[')),
                            isIncomplete: true,
                        };
                    }
                }
                else if (isInsideQuotation) {
                    return {
                        items: providers,
                        isIncomplete: true,
                    };
                }
                else {
                    return {
                        items: completionUtil_1.dataSourceProviderArguments,
                        isIncomplete: true,
                    };
                }
            }
            else if (currentLine.startsWith('url')) {
                // check if inside env
                if (isInsideAttribute(currentLineUntrimmed, position, '()')) {
                    suggestions = ['DATABASE_URL'];
                }
                else {
                    if (currentLine.includes('env')) {
                        return {
                            items: completionUtil_1.dataSourceUrlArguments.filter((a) => !a.label.includes('env')),
                            isIncomplete: true,
                        };
                    }
                    return {
                        items: completionUtil_1.dataSourceUrlArguments,
                        isIncomplete: true,
                    };
                }
            }
            break;
    }
    return {
        items: toCompletionItems(suggestions, vscode_languageserver_1.CompletionItemKind.Constant),
        isIncomplete: false,
    };
}
exports.getSuggestionForSupportedFields = getSuggestionForSupportedFields;
function getDefaultValues(currentLine, lines) {
    const suggestions = [
        {
            label: 'dbgenerated("")',
            kind: vscode_languageserver_1.CompletionItemKind.Function,
            documentation: 'The SQL definition of the default value which is generated by the database. This is not validated by Prisma.',
            insertText: 'dbgenerated("$0")',
            insertTextFormat: 2,
        },
    ];
    const fieldType = getFieldType(currentLine);
    if (!fieldType) {
        return [];
    }
    switch (fieldType) {
        case 'Int':
            suggestions.push({
                label: 'autoincrement()',
                kind: vscode_languageserver_1.CompletionItemKind.Function,
                documentation: 'Create a sequence of integers in the underlying database and assign the incremented values to the ID values of the created records based on the sequence.',
            });
            break;
        case 'DateTime':
            suggestions.push({
                label: 'now()',
                kind: vscode_languageserver_1.CompletionItemKind.Function,
                documentation: {
                    kind: vscode_languageserver_1.MarkupKind.Markdown,
                    value: 'Set a timestamp of the time when a record is created.',
                },
            });
            break;
        case 'String':
            suggestions.push({
                label: 'uuid()',
                kind: vscode_languageserver_1.CompletionItemKind.Function,
                documentation: {
                    kind: vscode_languageserver_1.MarkupKind.Markdown,
                    value: 'Generate a globally unique identifier based on the [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) spec.',
                },
            }, {
                label: 'cuid()',
                kind: vscode_languageserver_1.CompletionItemKind.Function,
                documentation: {
                    kind: vscode_languageserver_1.MarkupKind.Markdown,
                    value: 'Generate a globally unique identifier based on the [cuid](https://github.com/ericelliott/cuid) spec.',
                },
            });
            break;
        case 'Boolean':
            suggestions.push({ label: 'true', kind: vscode_languageserver_1.CompletionItemKind.Value }, { label: 'false', kind: vscode_languageserver_1.CompletionItemKind.Value });
            break;
    }
    const modelOrEnum = util_1.getModelOrEnumBlock(fieldType, lines);
    if (modelOrEnum && modelOrEnum.type === 'enum') {
        // get fields from enum block for suggestions
        const values = getFieldsFromCurrentBlock(lines, modelOrEnum);
        values.forEach((v) => suggestions.push({ label: v, kind: vscode_languageserver_1.CompletionItemKind.Value }));
    }
    return suggestions;
}
// checks if e.g. inside 'fields' or 'references' attribute
function isInsideFieldsOrReferences(currentLineUntrimmed, wordsBeforePosition, attributeName, position) {
    if (!isInsideAttribute(currentLineUntrimmed, position, '[]')) {
        return false;
    }
    // check if in fields or references
    const indexOfFields = wordsBeforePosition.findIndex((word) => word.includes('fields'));
    const indexOfReferences = wordsBeforePosition.findIndex((word) => word.includes('references'));
    if (indexOfFields === -1 && indexOfReferences === -1) {
        return false;
    }
    if ((indexOfFields === -1 && attributeName === 'fields') ||
        (indexOfReferences === -1 && attributeName === 'references')) {
        return false;
    }
    if (attributeName === 'references') {
        return indexOfReferences > indexOfFields;
    }
    if (attributeName === 'fields') {
        return indexOfFields > indexOfReferences;
    }
    return false;
}
function getFieldsFromCurrentBlock(lines, block, position) {
    const suggestions = [];
    let reachedStartLine = false;
    let field = '';
    for (const [key, item] of lines.entries()) {
        if (key === block.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (key === block.end.line) {
            break;
        }
        if (!item.startsWith('@@') && (!position || key !== position.line)) {
            field = item.replace(/ .*/, '');
            if (field !== '' && !field.startsWith('//')) {
                suggestions.push(field);
            }
        }
    }
    return suggestions;
}
function getTypesFromCurrentBlock(lines, block, position) {
    const suggestions = new Map();
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (key === block.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (key === block.end.line) {
            break;
        }
        if (!item.startsWith('@@') && (!position || key !== position.line)) {
            const type = getFieldType(item);
            if (type !== undefined) {
                /* eslint-disable @typescript-eslint/no-unsafe-assignment */
                const existingSuggestion = suggestions.get(type);
                if (!existingSuggestion) {
                    suggestions.set(type, [key]);
                }
                else {
                    existingSuggestion.push(key);
                    suggestions.set(type, existingSuggestion);
                }
                /* eslint-enable @typescript-eslint/no-unsafe-assignment */
            }
        }
    }
    return suggestions;
}
exports.getTypesFromCurrentBlock = getTypesFromCurrentBlock;
function getFieldType(line) {
    const wordsInLine = line.split(/\s+/);
    if (wordsInLine.length < 2) {
        return undefined;
    }
    const type = wordsInLine[1];
    if (type.length !== 0) {
        return type;
    }
    return undefined;
}
function getSuggestionsForRelationDirective(wordsBeforePosition, currentLineUntrimmed, lines, block, position) {
    // create deep copy
    const suggestions = klona_1.klona(completionUtil_1.relationArguments);
    const wordBeforePosition = wordsBeforePosition[wordsBeforePosition.length - 1];
    const stringTilPosition = currentLineUntrimmed
        .slice(0, position.character)
        .trim();
    if (wordBeforePosition.includes('@relation')) {
        return {
            items: suggestions,
            isIncomplete: false,
        };
    }
    if (isInsideFieldsOrReferences(currentLineUntrimmed, wordsBeforePosition, 'fields', position)) {
        return {
            items: toCompletionItems(getFieldsFromCurrentBlock(lines, block, position), vscode_languageserver_1.CompletionItemKind.Field),
            isIncomplete: false,
        };
    }
    if (isInsideFieldsOrReferences(currentLineUntrimmed, wordsBeforePosition, 'references', position)) {
        const referencedModelName = wordsBeforePosition[1].replace('?', '');
        const referencedBlock = util_1.getModelOrEnumBlock(referencedModelName, lines);
        // referenced model does not exist
        if (!referencedBlock || referencedBlock.type !== 'model') {
            return;
        }
        return {
            items: toCompletionItems(getFieldsFromCurrentBlock(lines, referencedBlock), vscode_languageserver_1.CompletionItemKind.Field),
            isIncomplete: false,
        };
    }
    if (stringTilPosition.endsWith(',')) {
        const referencesExist = wordsBeforePosition.some((a) => a.includes('references'));
        const fieldsExist = wordsBeforePosition.some((a) => a.includes('fields'));
        if (referencesExist && fieldsExist) {
            return;
        }
        if (referencesExist) {
            return {
                items: suggestions.filter((sugg) => !sugg.label.includes('references')),
                isIncomplete: false,
            };
        }
        if (fieldsExist) {
            return {
                items: suggestions.filter((sugg) => !sugg.label.includes('fields')),
                isIncomplete: false,
            };
        }
    }
}
function getSuggestionsForInsideAttributes(untrimmedCurrentLine, lines, position, block) {
    let suggestions = [];
    const wordsBeforePosition = untrimmedCurrentLine
        .slice(0, position.character)
        .trimLeft()
        .split(/\s+/);
    const wordBeforePosition = wordsBeforePosition[wordsBeforePosition.length - 1];
    if (wordBeforePosition.includes('@default')) {
        return {
            items: getDefaultValues(lines[position.line], lines),
            isIncomplete: false,
        };
    }
    else if (wordsBeforePosition.some((a) => a.includes('@@unique') || a.includes('@@id') || a.includes('@@index'))) {
        suggestions = getFieldsFromCurrentBlock(lines, block, position);
        // get parameters inside block attribute
        const parameterMatch = new RegExp(/(?<=\[).+?(?=\])/).exec(untrimmedCurrentLine);
        if (parameterMatch) {
            const existingParameters = parameterMatch[0]
                .split(',')
                .map((par) => par.trim());
            suggestions = suggestions.filter((s) => !existingParameters.includes(s));
        }
    }
    else if (wordsBeforePosition.some((a) => a.includes('@relation'))) {
        return getSuggestionsForRelationDirective(wordsBeforePosition, untrimmedCurrentLine, lines, block, position);
    }
    return {
        items: toCompletionItems(suggestions, vscode_languageserver_1.CompletionItemKind.Field),
        isIncomplete: false,
    };
}
exports.getSuggestionsForInsideAttributes = getSuggestionsForInsideAttributes;
//# sourceMappingURL=completions.js.map