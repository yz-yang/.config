"use strict";
/**
 * Imports
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadZip = exports.plusXSync = void 0;
const zlib_1 = __importDefault(require("zlib"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const fetch_engine_1 = require("@prisma/fetch-engine");
const node_fetch_1 = __importDefault(require("node-fetch"));
const tempy_1 = __importDefault(require("tempy"));
const p_retry_1 = __importDefault(require("p-retry"));
const hasha_1 = __importDefault(require("hasha"));
const util_1 = require("util");
const rimraf_1 = __importDefault(require("rimraf"));
const del = util_1.promisify(rimraf_1.default);
/**
 * Install prisma format
 */
function plusXSync(file) {
    const s = fs_1.default.statSync(file);
    const newMode = s.mode | 64 | 8 | 1;
    if (s.mode === newMode) {
        // console.log(`Execution permissions of ${file} are fine`)
        return;
    }
    const base8 = newMode.toString(8).slice(-3);
    // console.log(`Have to call plusX on ${file}`)
    fs_1.default.chmodSync(file, base8);
}
exports.plusXSync = plusXSync;
//
// From https://github.com/prisma/prisma/blob/4bd1d2850f1dc7c09054fd7c776c3707fc601b55/src/packages/fetch-engine/src/downloadZip.ts#L21
//
function fetchSha256(url) {
    return __awaiter(this, void 0, void 0, function* () {
        // We get a string like this:
        // "3c82ee6cd9fedaec18a5e7cd3fc41f8c6b3dd32575dc13443d96aab4bd018411  query-engine.gz\n"
        // So we split it by whitespace and just get the hash, as that's what we're interested in
        const [zippedSha256, sha256] = [
            (yield node_fetch_1.default(`${url}.sha256`, {
                agent: fetch_engine_1.getProxyAgent(url),
            }).then((res) => res.text())).split(/\s+/)[0],
            (yield node_fetch_1.default(`${url.slice(0, url.length - 3)}.sha256`, {
                agent: fetch_engine_1.getProxyAgent(url.slice(0, url.length - 3)),
            }).then((res) => res.text())).split(/\s+/)[0],
        ];
        return { sha256, zippedSha256 };
    });
}
function downloadZip(url, target) {
    return __awaiter(this, void 0, void 0, function* () {
        const tmpDir = tempy_1.default.directory();
        const partial = path_1.default.join(tmpDir, 'partial');
        const { sha256, zippedSha256 } = yield fetchSha256(url);
        const result = yield p_retry_1.default(() => __awaiter(this, void 0, void 0, function* () {
            try {
                const resp = yield node_fetch_1.default(url, {
                    compress: false,
                    agent: fetch_engine_1.getProxyAgent(url),
                });
                if (resp.status !== 200) {
                    throw new Error(resp.statusText + ' ' + url);
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const lastModified = resp.headers.get('last-modified');
                const ws = fs_1.default.createWriteStream(partial);
                // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor
                return yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                    resp.body.on('error', reject);
                    const gunzip = zlib_1.default.createGunzip();
                    gunzip.on('error', reject);
                    const zipStream = resp.body.pipe(gunzip);
                    const zippedHashPromise = hasha_1.default.fromStream(resp.body, {
                        algorithm: 'sha256',
                    });
                    const hashPromise = hasha_1.default.fromStream(zipStream, {
                        algorithm: 'sha256',
                    });
                    zipStream.pipe(ws);
                    ws.on('error', reject).on('close', () => {
                        resolve({ lastModified, sha256, zippedSha256 });
                    });
                    const hash = yield hashPromise;
                    const zippedHash = yield zippedHashPromise;
                    if (zippedHash !== zippedSha256) {
                        throw new Error(`sha256 of ${url} (zipped) should be ${zippedSha256} but is ${zippedHash}`);
                    }
                    if (hash !== sha256) {
                        throw new Error(`sha256 of ${url} (uzipped) should be ${sha256} but is ${hash}`);
                    }
                }));
            }
            finally {
                //
            }
        }), {
            retries: 2,
            onFailedAttempt: (err) => console.error(err),
        });
        fs_1.default.copyFileSync(partial, target);
        // it's ok if the unlink fails
        try {
            yield del(partial);
            yield del(tmpDir);
        }
        catch (e) {
            console.error(e);
        }
        return result;
    });
}
exports.downloadZip = downloadZip;
function install(url, fmtPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetDir = path_1.default.dirname(fmtPath);
        try {
            fs_1.default.accessSync(targetDir, fs_1.default.constants.W_OK);
        }
        catch (e) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            if (e.code !== 'EACCES') {
                throw e;
            }
            else {
                throw new Error(`Can't write to ${targetDir}`);
            }
        }
        try {
            console.debug(`Downloading ${url} to ${fmtPath}`);
            yield downloadZip(url, fmtPath);
        }
        catch (e) {
            console.error(`Language Server failed while downloading url ${url} with fmtPath ${fmtPath}.`);
            console.error(e);
            throw e;
        }
        if (process.platform !== 'win32') {
            plusXSync(fmtPath);
        }
        return fmtPath;
    });
}
exports.default = install;
//# sourceMappingURL=install.js.map