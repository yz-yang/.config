"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExperimentalFeaturesRange = exports.getModelOrEnumBlock = exports.getBlockAtPosition = exports.getWordAtPosition = exports.isFirstInsideBlock = exports.convertDocumentTextToTrimmedLineArray = exports.getCurrentLine = exports.fullDocumentRange = exports.Block = void 0;
const node_1 = require("vscode-languageserver/node");
class Block {
    constructor(type, start, end, name) {
        this.type = type;
        this.start = start;
        this.end = end;
        this.name = name;
    }
}
exports.Block = Block;
function fullDocumentRange(document) {
    const lastLineId = document.lineCount - 1;
    return {
        start: { line: 0, character: 0 },
        end: { line: lastLineId, character: Number.MAX_SAFE_INTEGER },
    };
}
exports.fullDocumentRange = fullDocumentRange;
function getCurrentLine(document, line) {
    return document.getText({
        start: { line: line, character: 0 },
        end: { line: line, character: Number.MAX_SAFE_INTEGER },
    });
}
exports.getCurrentLine = getCurrentLine;
function convertDocumentTextToTrimmedLineArray(document) {
    return Array(document.lineCount)
        .fill(0)
        .map((_, i) => getCurrentLine(document, i).trim());
}
exports.convertDocumentTextToTrimmedLineArray = convertDocumentTextToTrimmedLineArray;
function isFirstInsideBlock(position, currentLine) {
    if (currentLine.trim().length === 0) {
        return true;
    }
    const stringTilPosition = currentLine.slice(0, position.character);
    const matchArray = /\w+/.exec(stringTilPosition);
    if (!matchArray) {
        return true;
    }
    return (matchArray.length === 1 &&
        matchArray.index !== undefined &&
        stringTilPosition.length - matchArray.index - matchArray[0].length === 0);
}
exports.isFirstInsideBlock = isFirstInsideBlock;
function getWordAtPosition(document, position) {
    const currentLine = getCurrentLine(document, position.line);
    // search for the word's beginning and end
    const beginning = currentLine
        .slice(0, position.character + 1)
        .search(/\S+$/);
    const end = currentLine.slice(position.character).search(/\W/);
    if (end < 0) {
        return '';
    }
    return currentLine.slice(beginning, end + position.character);
}
exports.getWordAtPosition = getWordAtPosition;
function getBlockAtPosition(line, lines) {
    let blockType = '';
    let blockName = '';
    let blockStart = node_1.Position.create(0, 0);
    let blockEnd = node_1.Position.create(0, 0);
    const allowedBlockIdentifiers = ['model', 'enum', 'datasource', 'generator'];
    // get block beginning
    let reachedLine = false;
    for (const [key, item] of lines.reverse().entries()) {
        const actualIndex = lines.length - 1 - key;
        if (actualIndex === line) {
            reachedLine = true;
        }
        if (!reachedLine) {
            continue;
        }
        if (allowedBlockIdentifiers.some((identifier) => item.startsWith(identifier)) &&
            item.includes('{')) {
            const index = item.search(/\s+/);
            blockType = ~index ? item.slice(0, index) : item;
            blockName = item.slice(blockType.length, item.length - 2).trim();
            blockStart = node_1.Position.create(actualIndex, 0);
            break;
        }
        // not inside a block
        if (item.includes('}')) {
            lines.reverse();
            return;
        }
    }
    reachedLine = false;
    // get block ending
    for (const [key, item] of lines.reverse().entries()) {
        if (key === line) {
            reachedLine = true;
        }
        if (!reachedLine) {
            continue;
        }
        // check if block ends here
        if (item.startsWith('}')) {
            blockEnd = node_1.Position.create(key, 1);
            return new Block(blockType, blockStart, blockEnd, blockName);
        }
    }
    return;
}
exports.getBlockAtPosition = getBlockAtPosition;
function getModelOrEnumBlock(blockName, lines) {
    // get start position of model type
    const results = lines
        .map((line, index) => {
        if ((line.includes('model') && line.includes(blockName)) ||
            (line.includes('enum') && line.includes(blockName))) {
            return index;
        }
    })
        .filter((index) => index !== undefined);
    if (results.length === 0) {
        return;
    }
    const foundBlocks = results
        .map((result) => {
        const block = getBlockAtPosition(result, lines);
        if (block && block.name === blockName) {
            return block;
        }
    })
        .filter((block) => block !== undefined);
    if (foundBlocks.length !== 1) {
        return;
    }
    if (!foundBlocks[0]) {
        return;
    }
    return foundBlocks[0];
}
exports.getModelOrEnumBlock = getModelOrEnumBlock;
function getExperimentalFeaturesRange(document) {
    const lines = convertDocumentTextToTrimmedLineArray(document);
    const experimentalFeatures = 'experimentalFeatures';
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (item.startsWith('generator') && item.includes('{')) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (reachedStartLine && item.startsWith('}')) {
            return;
        }
        if (item.startsWith(experimentalFeatures)) {
            const startIndex = getCurrentLine(document, key).indexOf(experimentalFeatures);
            return {
                start: { line: key, character: startIndex },
                end: { line: key, character: startIndex + experimentalFeatures.length },
            };
        }
    }
}
exports.getExperimentalFeaturesRange = getExperimentalFeaturesRange;
//# sourceMappingURL=util.js.map