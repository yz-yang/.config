"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractCurrentName = exports.insertMapAttribute = exports.mapExistsAlready = exports.insertBasicRename = exports.renameReferencesForModelName = exports.renameReferencesForEnumValue = exports.renameReferencesForFieldValue = exports.printLogMessage = exports.isEnumValue = exports.isEnumName = exports.isModelName = exports.isValidFieldName = exports.isRelationField = exports.extractModelName = void 0;
const completions_1 = require("../completion/completions");
const util_1 = require("../util");
function extractFirstWord(line) {
    return line.replace(/ .*/, '');
}
function getType(currentLine) {
    const wordsInLine = currentLine.split(/\s+/);
    if (wordsInLine.length < 2) {
        return '';
    }
    return wordsInLine[1].replace('?', '').replace('[]', '');
}
function extractModelName(line) {
    const blockType = extractFirstWord(line);
    return line.slice(blockType.length, line.length - 1).trim();
}
exports.extractModelName = extractModelName;
function isRelationField(currentLine, lines) {
    const relationNames = completions_1.getAllRelationNames(lines);
    const type = getType(currentLine);
    if (type == '') {
        return false;
    }
    return relationNames.includes(type);
}
exports.isRelationField = isRelationField;
function isValidFieldName(currentLine, position, currentBlock, document) {
    if (currentBlock.type !== 'model' ||
        position.line == currentBlock.start.line ||
        position.line == currentBlock.end.line) {
        return false;
    }
    if (currentLine.startsWith('@')) {
        return false;
    }
    // check if position is inside first word
    const currentLineUntrimmed = util_1.getCurrentLine(document, position.line);
    const firstWord = extractFirstWord(currentLine);
    const indexOfFirstWord = currentLineUntrimmed.indexOf(firstWord);
    const isFieldName = indexOfFirstWord <= position.character &&
        indexOfFirstWord + firstWord.length >= position.character;
    if (!isFieldName) {
        return false;
    }
    // remove type modifiers
    const type = getType(currentLine);
    return type !== '' && type !== undefined;
}
exports.isValidFieldName = isValidFieldName;
function isModelName(position, block, lines, document) {
    if (block.type !== 'model') {
        return false;
    }
    if (position.line === block.start.line) {
        return position.character > 5;
    }
    return renameModelOrEnumWhereUsedAsType(block, lines, document, position, 'model');
}
exports.isModelName = isModelName;
function isEnumName(position, block, lines, document) {
    if (block.type === 'enum' && position.line === block.start.line) {
        return position.character > 4;
    }
    return renameModelOrEnumWhereUsedAsType(block, lines, document, position, 'enum');
}
exports.isEnumName = isEnumName;
function renameModelOrEnumWhereUsedAsType(block, lines, document, position, blockType) {
    if (block.type !== 'model') {
        return false;
    }
    const allRelationNames = completions_1.getAllRelationNames(lines);
    const currentName = util_1.getWordAtPosition(document, position);
    const isRelation = allRelationNames.includes(currentName);
    if (!isRelation) {
        return false;
    }
    const indexOfRelation = lines.findIndex((l) => l.startsWith(blockType) && l.includes(currentName));
    return indexOfRelation !== -1;
}
function isEnumValue(currentLine, position, currentBlock, document) {
    return (currentBlock.type === 'enum' &&
        position.line !== currentBlock.start.line &&
        !currentLine.startsWith('@@') &&
        !util_1.getWordAtPosition(document, position).startsWith('@'));
}
exports.isEnumValue = isEnumValue;
function printLogMessage(currentName, newName, isEnumRename, isModelRename, isFieldRename, isEnumValueRename) {
    const message = `'${currentName}' was renamed to '${newName}'`;
    let typeOfRename = '';
    if (isEnumRename) {
        typeOfRename = 'Enum ';
    }
    else if (isFieldRename) {
        typeOfRename = 'Field ';
    }
    else if (isModelRename) {
        typeOfRename = 'Model ';
    }
    else if (isEnumValueRename) {
        typeOfRename = 'Enum value ';
    }
    console.log(typeOfRename + message);
}
exports.printLogMessage = printLogMessage;
function insertInlineRename(currentName, line) {
    return {
        range: {
            start: {
                line: line,
                character: Number.MAX_VALUE,
            },
            end: {
                line: line,
                character: Number.MAX_VALUE,
            },
        },
        newText: ` @map("${currentName}")`,
    };
}
function insertMapBlockAttribute(oldName, block) {
    return {
        range: {
            start: {
                line: block.end.line,
                character: 0,
            },
            end: block.end,
        },
        newText: `\t@@map("${oldName}")\n}`,
    };
}
function positionIsNotInsideSearchedBlocks(line, searchedBlocks) {
    if (searchedBlocks.length === 0) {
        return true;
    }
    return !searchedBlocks.some((block) => line >= block.start.line && line <= block.end.line);
}
/**
 * Renames references in any '@@index', '@@id' and '@@unique' attributes in the same model.
 * Renames references in any referenced fields inside a '@relation' attribute in the same model (fields: []).
 * Renames references inside a '@relation' attribute in other model blocks (references: []).
 */
function renameReferencesForFieldValue(currentValue, newName, document, lines, block, isRelationFieldRename) {
    const edits = [];
    const searchStringsSameBlock = ['@@index', '@@id', '@@unique'];
    const relationAttribute = '@relation';
    // search in same model first
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (key === block.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (key === block.end.line) {
            break;
        }
        if (item.includes(relationAttribute) &&
            item.includes(currentValue) &&
            !isRelationFieldRename) {
            // search for fields references
            const currentLineUntrimmed = util_1.getCurrentLine(document, key);
            const indexOfFieldsStart = currentLineUntrimmed.indexOf('fields:');
            const indexOfFieldEnd = currentLineUntrimmed.slice(indexOfFieldsStart).indexOf(']') +
                indexOfFieldsStart;
            const fields = currentLineUntrimmed.slice(indexOfFieldsStart, indexOfFieldEnd + 1);
            const indexOfFoundValue = fields.indexOf(currentValue);
            const fieldValues = completions_1.getValuesInsideBrackets(fields);
            if (indexOfFoundValue !== -1 && fieldValues.includes(currentValue)) {
                // found a referenced field
                edits.push({
                    range: {
                        start: {
                            line: key,
                            character: indexOfFieldsStart + indexOfFoundValue,
                        },
                        end: {
                            line: key,
                            character: indexOfFieldsStart + indexOfFoundValue + currentValue.length,
                        },
                    },
                    newText: newName,
                });
            }
        }
        // search for references in index, id and unique block attributes
        if (searchStringsSameBlock.some((s) => item.includes(s)) &&
            item.includes(currentValue)) {
            const currentLineUntrimmed = util_1.getCurrentLine(document, key);
            const valuesInsideBracket = completions_1.getValuesInsideBrackets(currentLineUntrimmed);
            if (valuesInsideBracket.includes(currentValue)) {
                const indexOfCurrentValue = currentLineUntrimmed.indexOf(currentValue);
                edits.push({
                    range: {
                        start: {
                            line: key,
                            character: indexOfCurrentValue,
                        },
                        end: {
                            line: key,
                            character: indexOfCurrentValue + currentValue.length,
                        },
                    },
                    newText: newName,
                });
            }
        }
    }
    // search for references in other model blocks
    for (const [index, value] of lines.entries()) {
        if (value.includes(block.name) &&
            value.includes(currentValue) &&
            value.includes(relationAttribute)) {
            const currentLineUntrimmed = util_1.getCurrentLine(document, index);
            // get the index of the second word
            const indexOfReferences = currentLineUntrimmed.indexOf('references:');
            const indexOfReferencesEnd = currentLineUntrimmed.slice(indexOfReferences).indexOf(']') +
                indexOfReferences;
            const references = currentLineUntrimmed.slice(indexOfReferences, indexOfReferencesEnd + 1);
            const indexOfFoundValue = references.indexOf(currentValue);
            const referenceValues = completions_1.getValuesInsideBrackets(references);
            if (indexOfFoundValue !== -1 && referenceValues.includes(currentValue)) {
                edits.push({
                    range: {
                        start: {
                            line: index,
                            character: indexOfReferences + indexOfFoundValue,
                        },
                        end: {
                            line: index,
                            character: indexOfReferences + indexOfFoundValue + currentValue.length,
                        },
                    },
                    newText: newName,
                });
            }
        }
    }
    return edits;
}
exports.renameReferencesForFieldValue = renameReferencesForFieldValue;
/**
 * Renames references where the current enum value is used as a default value in other model blocks.
 */
function renameReferencesForEnumValue(currentValue, newName, document, lines, enumName) {
    const edits = [];
    const searchString = `@default(${currentValue})`;
    for (const [index, value] of lines.entries()) {
        if (value.includes(searchString) && value.includes(enumName)) {
            const currentLineUntrimmed = util_1.getCurrentLine(document, index);
            // get the index of the second word
            const indexOfCurrentName = currentLineUntrimmed.indexOf(searchString);
            edits.push({
                range: {
                    start: {
                        line: index,
                        character: indexOfCurrentName,
                    },
                    end: {
                        line: index,
                        character: indexOfCurrentName + searchString.length,
                    },
                },
                newText: `@default(${newName})`,
            });
        }
    }
    return edits;
}
exports.renameReferencesForEnumValue = renameReferencesForEnumValue;
/**
 * Renames references where the model name is used as a relation type in the same and other model blocks.
 */
function renameReferencesForModelName(currentName, newName, document, lines) {
    const searchedBlocks = [];
    const edits = [];
    for (const [index, value] of lines.entries()) {
        // check if inside model
        if (value.includes(currentName) &&
            positionIsNotInsideSearchedBlocks(index, searchedBlocks)) {
            const block = util_1.getBlockAtPosition(index, lines);
            if (block && block.type == 'model') {
                searchedBlocks.push(block);
                // search block for references
                const types = completions_1.getTypesFromCurrentBlock(lines, block);
                for (const f of types.keys()) {
                    if (f.replace('?', '').replace('[]', '') === currentName) {
                        // replace here
                        const foundLines = types.get(f);
                        if (!foundLines) {
                            return edits;
                        }
                        for (const line of foundLines) {
                            const currentLineUntrimmed = util_1.getCurrentLine(document, line);
                            const wordsInLine = lines[line].split(/\s+/);
                            // get the index of the second word
                            const indexOfFirstWord = currentLineUntrimmed.indexOf(wordsInLine[0]);
                            const indexOfCurrentName = currentLineUntrimmed.indexOf(currentName, indexOfFirstWord + wordsInLine[0].length);
                            edits.push({
                                range: {
                                    start: {
                                        line: line,
                                        character: indexOfCurrentName,
                                    },
                                    end: {
                                        line: line,
                                        character: indexOfCurrentName + currentName.length,
                                    },
                                },
                                newText: newName,
                            });
                        }
                    }
                }
            }
        }
    }
    return edits;
}
exports.renameReferencesForModelName = renameReferencesForModelName;
function mapFieldAttributeExistsAlready(line) {
    return line.includes('@map(');
}
function mapBlockAttributeExistsAlready(block, lines) {
    let reachedStartLine = false;
    for (const [key, item] of lines.entries()) {
        if (key === block.start.line + 1) {
            reachedStartLine = true;
        }
        if (!reachedStartLine) {
            continue;
        }
        if (key === block.end.line) {
            break;
        }
        if (item.startsWith('@@map(')) {
            return true;
        }
    }
    return false;
}
function insertBasicRename(newName, currentName, document, line) {
    const currentLineUntrimmed = util_1.getCurrentLine(document, line);
    const indexOfCurrentName = currentLineUntrimmed.indexOf(currentName);
    return {
        range: {
            start: {
                line: line,
                character: indexOfCurrentName,
            },
            end: {
                line: line,
                character: indexOfCurrentName + currentName.length,
            },
        },
        newText: newName,
    };
}
exports.insertBasicRename = insertBasicRename;
function mapExistsAlready(currentLine, lines, block, isModelOrEnumRename) {
    if (isModelOrEnumRename) {
        return mapBlockAttributeExistsAlready(block, lines);
    }
    else {
        return mapFieldAttributeExistsAlready(currentLine);
    }
}
exports.mapExistsAlready = mapExistsAlready;
function insertMapAttribute(currentName, position, block, isModelOrEnumRename) {
    if (isModelOrEnumRename) {
        return insertMapBlockAttribute(currentName, block);
    }
    else {
        return insertInlineRename(currentName, position.line);
    }
}
exports.insertMapAttribute = insertMapAttribute;
function extractCurrentName(line, isModelOrEnumRename, isEnumValueRename, isFieldRename, document, position) {
    if (isModelOrEnumRename) {
        const currentLineUntrimmed = util_1.getCurrentLine(document, position.line);
        const currentLineTillPosition = currentLineUntrimmed
            .slice(0, position.character +
            currentLineUntrimmed.slice(position.character).search(/\W/))
            .trim();
        const wordsBeforePosition = currentLineTillPosition.split(/\s+/);
        if (wordsBeforePosition.length < 2) {
            return '';
        }
        return wordsBeforePosition[1];
    }
    if (isEnumValueRename || isFieldRename) {
        return extractFirstWord(line);
    }
    return '';
}
exports.extractCurrentName = extractCurrentName;
//# sourceMappingURL=renameUtil.js.map